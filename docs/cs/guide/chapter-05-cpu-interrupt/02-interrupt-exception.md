---
tags:
  - Interrupt
  - Exception
  - CPU
  - Computer Science
  - Overview
---

# Chapter 5-2: 인터럽트와 예외 개요

## 🎯 CPU의 긴급 호출 시스템

인터럽트와 예외는 현대 컴퓨팅의 심장이라 할 수 있습니다. 키보드 입력부터 네트워크 통신, 메모리 보호까지 모든 것이 이 메커니즘을 통해 이루어집니다.

2020년 클라우드플레어의 27분 서비스 마비 사건처럼, 인터럽트 시스템의 장애는 전 세계 인터넷 서비스를 정지시킬 수 있을 만큼 중요합니다.

## 📚 학습 로드맵

이 섹션은 4개의 전문화된 문서로 구성되어 있습니다:

### 1️⃣ [인터럽트 기초와 개념](02a-interrupt-basics.md)

- 인터럽트가 왜 필요한가? (폴링 vs 인터럽트)
- 인터럽트 분류: 하드웨어 vs 소프트웨어
- IDT(인터럽트 벡터 테이블) - CPU의 전화번호부
- 실제 사례: 게임에서 마우스 인터럽트 최적화

### 2️⃣ [인터럽트 처리 과정과 예외](02b-interrupt-processing.md)

- 6단계 인터럽트 처리 과정 (IDT → 핸들러 → IRET)
- 인터럽트 핸들러 작성 원칙과 실제 구현
- 예외 처리: Fault, Trap, Abort의 차이
- 화성 탐사선을 구한 예외 처리 사례

### 3️⃣ [인터럽트 컨트롤러와 최적화](02c-interrupt-controllers.md)

- PIC에서 APIC로의 진화 (8개 → 40억개 인터럽트)
- 인터럽트 결합(Coalescing)으로 성능 향상
- CPU 친화도(Affinity) 설정을 통한 로드 밸런싱
- 구글 데이터센터의 전력 절약 기법

### 4️⃣ [소프트 인터럽트와 실시간 처리](02d-software-interrupts.md)

- Softirq와 Tasklet - 인터럽트의 뒷정리
- ksoftirqd 데몬의 역할과 성능 임팩트
- 실시간 시스템의 마이크로초 단위 요구사항
- 인터럽트 디버깅과 스톰 감지 기법

## 🎯 핵심 개념 비교표

| 구분 | 하드웨어 인터럽트 | 소프트웨어 인터럽트 | 실시간 인터럽트 |
|------|------------------|-------------------|-----------------|
| **발생 원인** | 외부 장치 (키보드, 네트워크) | CPU 내부 (예외, 시스템 콜) | 시간 기반 (타이머) |
| **우선순위** | 높음 | 중간 | 최고 |
| **지연 시간** | 마이크로초 | 나노초 | 서브 마이크로초 |
| **예시** | IRQ1 (키보드) | INT 0x80 (시스템 콜) | APIC 타이머 |

## 🚀 실전 활용 시나리오

### 시나리오 1: 게임 서버 최적화

**문제**: 60 FPS 게임에서 인터럽트 지연으로 프레임 드롭 발생
**해결**: 인터럽트 친화도 설정으로 CPU 분산, 성능 2배 향상

### 시나리오 2: 데이터센터 전력 절약

**문제**: 초당 수조개 인터럽트로 인한 높은 전력 소비
**해결**: 인터럽트 결합으로 CPU 깨우기 횟수 1000배 감소

### 시나리오 3: 자율주행 안전 시스템

**문제**: 브레이크 인터럽트 지연이 생명과 직결
**해결**: 실시간 인터럽트 우선순위와 전용 CPU 할당

## 🎭 학습 전략

### 초보자 (추천 순서)

1. [기초와 개념](02a-interrupt-basics.md) → 인터럽트가 무엇인지 이해
2. [처리 과정](02b-interrupt-processing.md) → 실제 동작 메커니즘 학습
3. 간단한 인터럽트 핸들러 작성 연습

### 중급자 (심화 학습)

1. [컨트롤러와 최적화](02c-interrupt-controllers.md) → 성능 최적화 기법
2. [실시간 처리](02d-software-interrupts.md) → 고급 디버깅과 튜닝
3. 실제 프로덕션 환경 인터럽트 분석

### 고급자 (전문가 과정)

1. 모든 섹션 통합 이해
2. 커널 소스코드 분석
3. 인터럽트 드라이버 개발

## 🔗 연관 학습

### 선행 학습

- [CPU 아키텍처](01-cpu-architecture.md) - Protection Ring과 실행 모드
- [메모리 관리](../../chapter-02-memory/) - 가상 메모리와 페이지 폴트

### 후속 학습  

- [컨텍스트 스위칭](03-context-switching.md) - 인터럽트 기반 프로세스 전환
- [파일 시스템](../../chapter-06-file-io/) - I/O 인터럽트와 파일 처리

### 실무 적용

- [네트워크 프로그래밍](../../chapter-07-network-programming/) - 네트워크 인터럽트 최적화
- [시스템 설계](../../chapter-16-system-design-patterns/) - 대규모 시스템에서의 인터럽트 관리

## 🎯 핵심 질문과 답변

### Q: 키보드를 누르면 CPU는 어떻게 즉시 반응하는가?

**A**: IRQ1 인터럽트가 발생하여 CPU가 현재 작업을 중단하고 키보드 핸들러를 실행합니다. 단 6마이크로초 만에 완료됩니다.

### Q: 0으로 나누면 왜 프로그램이 죽는가?

**A**: CPU가 Division by Zero 예외(벡터 0)를 발생시키고, OS가 SIGFPE 신호를 프로세스에 전송하여 종료시킵니다.

### Q: 하드웨어 인터럽트와 소프트웨어 인터럽트의 차이는?

**A**: 하드웨어 인터럽트는 외부 장치에서 발생(비동기), 소프트웨어 인터럽트는 CPU 내부에서 발생(동기)합니다.

### Q: 실시간 시스템에서 인터럽트 지연을 최소화하는 방법은?

**A**: 전용 CPU 할당, 실시간 우선순위 설정, 인터럽트 핸들러 최적화, 그리고 하드웨어 레벨 튜닝을 조합합니다.

## 🛠️ 실무 명령어

```bash
# 1. 인터럽트 현황 모니터링
watch -d -n 1 'cat /proc/interrupts'

# 2. 인터럽트 친화도 설정
echo 2 > /proc/irq/24/smp_affinity  # NIC를 CPU1에 할당

# 3. 소프트 인터럽트 상태 확인
cat /proc/softirqs

# 4. 네트워크 인터럽트 결합 튜닝
ethtool -C eth0 rx-usecs 100
```text

## 📊 성능 벤치마크

### 인터럽트 최적화 전후 비교

```text
Before:
- 인터럽트/초: 1,000,000개
- CPU 사용률: 95%
- 전력 소비: 95W

After:
- 인터럽트/초: 1,000개 (1000배 감소)
- CPU 사용률: 45%
- 전력 소비: 45W (50% 절약)
```

## 🔍 디버깅 체크리스트

- [ ] `/proc/interrupts`에서 인터럽트 분산 상태 확인
- [ ] `mpstat -P ALL`로 CPU별 인터럽트 부하 확인  
- [ ] `ethtool -S`로 네트워크 인터럽트 통계 분석
- [ ] `perf record -e irq:`로 인터럽트 성능 프로파일링
- [ ] 인터럽트 스톰 감지 스크립트 실행

---

**시작하기**: [인터럽트 기초와 개념](02a-interrupt-basics.md)에서 인터럽트의 필요성과 기본 동작을 학습합니다.
