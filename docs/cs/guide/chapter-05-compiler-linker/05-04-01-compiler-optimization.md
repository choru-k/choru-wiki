---
tags:
  - balanced
  - compiler-optimization
  - intermediate
  - loop-optimization
  - medium-read
  - performance
  - simd
  - vectorization
  - ì‹œìŠ¤í…œí”„ë¡œê·¸ë˜ë°
difficulty: INTERMEDIATE
learning_time: "3-4ì‹œê°„"
main_topic: "ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë°"
priority_score: 4
---

# 5.4.1: ì»´íŒŒì¼ëŸ¬ ìµœì í™”

## ì´ ë¬¸ì„œë¥¼ ì½ìœ¼ë©´ ë‹µí•  ìˆ˜ ìˆëŠ” ì§ˆë¬¸ë“¤

- ì»´íŒŒì¼ëŸ¬ëŠ” ìš°ë¦¬ ì½”ë“œë¥¼ ì–´ë–»ê²Œ ë” ë¹ ë¥´ê²Œ ë§Œë“¤ê¹Œìš”?
- -O0, -O1, -O2, -O3ì˜ ì‹¤ì œ ì°¨ì´ëŠ” ë¬´ì—‡ì¼ê¹Œìš”?
- ì™œ ë””ë²„ê·¸ ë¹Œë“œì™€ ë¦´ë¦¬ì¦ˆ ë¹Œë“œì˜ ì„±ëŠ¥ ì°¨ì´ê°€ í´ê¹Œìš”?
- ìµœì í™”ê°€ ë²„ê·¸ë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” ë­”ê°€ìš”?
- ì»´íŒŒì¼ëŸ¬ ìµœì í™”ë¥¼ ë¯¿ì–´ë„ ë ê¹Œìš”, ì•„ë‹ˆë©´ ìˆ˜ë™ ìµœì í™”ê°€ í•„ìš”í• ê¹Œìš”?

## ë“¤ì–´ê°€ë©°: ì»´íŒŒì¼ëŸ¬ëŠ” ë§ˆë²•ì‚¬ì¸ê°€?

ë‘ ê°œë°œìê°€ ê°™ì€ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í–ˆì–´ìš”. í•œ ëª…ì€ ìµœì í™”ì— ì‹ ê²½ ì“°ì§€ ì•Šê³  ì½ê¸° ì‰½ê²Œ ì‘ì„±í–ˆê³ , ë‹¤ë¥¸ í•œ ëª…ì€ ì„±ëŠ¥ì„ ìœ„í•´ ë³µì¡í•˜ê²Œ ì‘ì„±í–ˆì–´ìš”. ê·¸ëŸ°ë° ì»´íŒŒì¼ í›„ ì„±ëŠ¥ì„ ì¸¡ì •í•´ë³´ë‹ˆ ê±°ì˜ ê°™ì•˜ì–´ìš”. ëŒ€ì²´ ì–´ë–»ê²Œ ëœ ì¼ì¼ê¹Œìš”?

í˜„ëŒ€ ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¨ìˆœí•œ ë²ˆì—­ê¸°ê°€ ì•„ë‹™ë‹ˆë‹¤. ìˆ˜ì‹­ ë…„ê°„ ì¶•ì ëœ ìµœì í™” ê¸°ë²•ì„ ì‚¬ìš©í•˜ì—¬ ìš°ë¦¬ê°€ ì‘ì„±í•œ ì½”ë“œë¥¼ ë†€ëë„ë¡ íš¨ìœ¨ì ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ë•Œë¡œëŠ” ìš°ë¦¬ê°€ ìƒìƒí•˜ì§€ ëª»í•œ ë°©ë²•ìœ¼ë¡œ ì½”ë“œë¥¼ ê°œì„ í•˜ê¸°ë„ í•©ë‹ˆë‹¤.

í•˜ì§€ë§Œ ì»´íŒŒì¼ëŸ¬ëŠ” ë§ˆë²•ì‚¬ê°€ ì•„ë‹ˆì—ìš”. ì½”ë“œì˜ ì˜ë„ë¥¼ ì™„ë²½í•˜ê²Œ ì´í•´í•˜ì§€ ëª»í•˜ê³ , ë•Œë¡œëŠ” ìš°ë¦¬ ê¸°ëŒ€ì™€ ë‹¤ë¥´ê²Œ ë™ì‘í•´ìš”. ì»´íŒŒì¼ëŸ¬ ìµœì í™”ë¥¼ ì´í•´í•˜ë©´ ë” ì¢‹ì€ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆì–´ìš”.

## 1. ìµœì í™”ì˜ ê¸°ë³¸ ì›ë¦¬

### 1.1 ìµœì í™”ì˜ ëª©í‘œ

ì»´íŒŒì¼ëŸ¬ ìµœì í™”ëŠ” ì—¬ëŸ¬ ëª©í‘œë¥¼ ì¶”êµ¬í•©ë‹ˆë‹¤:

```mermaid
graph TD
    O[ìµœì í™” ëª©í‘œ] --> S["ì†ë„
Speed"]
    O --> M["í¬ê¸°
Size"]
    O --> P["ì „ë ¥
Power"]
    O --> C["ìºì‹œ
Cache"]

    S --> S1["ì‹¤í–‰ ì‹œê°„ ë‹¨ì¶•"]
    M --> M1["ë°”ì´ë„ˆë¦¬ í¬ê¸° ê°ì†Œ"]
    P --> P1["ì „ë ¥ ì†Œë¹„ ê°ì†Œ"]
    C --> C1["ìºì‹œ ë¯¸ìŠ¤ ê°ì†Œ"]

    style O fill:#FFE082
    style S fill:#81C784
    style M fill:#90CAF9
    style P fill:#CE93D8
    style C fill:#FFAB91
```

ë•Œë¡œëŠ” ì´ ëª©í‘œë“¤ì´ ì¶©ëŒí•©ë‹ˆë‹¤:

- ì†ë„ë¥¼ ìœ„í•´ ì½”ë“œë¥¼ ë³µì œí•˜ë©´ â†’ í¬ê¸° ì¦ê°€
- í¬ê¸°ë¥¼ ì¤„ì´ê¸° ìœ„í•´ í•¨ìˆ˜ í˜¸ì¶œí•˜ë©´ â†’ ì†ë„ ê°ì†Œ

### 1.2 ìµœì í™”ì˜ ì œì•½

ì»´íŒŒì¼ëŸ¬ëŠ” í”„ë¡œê·¸ë¨ì˜ ì˜ë¯¸ë¥¼ ë°”ê¾¸ì§€ ì•ŠëŠ” ì„ ì—ì„œ ìµœì í™”í•´ìš”:

```c
// ì›ë³¸ ì½”ë“œ
int calculate(int x) {
    int a = x * 2;
    int b = x * 2;
    return a + b;
}

// ìµœì í™” ê°€ëŠ¥: ì˜ë¯¸ê°€ ê°™ìŒ
int calculate_opt1(int x) {
    return x * 4;  // 2*x + 2*x = 4*x
}

// ìµœì í™” ë¶ˆê°€ëŠ¥: ì˜ë¯¸ê°€ ë‹¤ë¦„
int calculate_wrong(int x) {
    return 0;  // ì˜ëª»ëœ ìµœì í™”!
}
```

### 1.3 ìµœì í™” ë ˆë²¨

GCC/Clangì˜ ìµœì í™” ë ˆë²¨:

| ë ˆë²¨ | ì„¤ëª… | ìš©ë„ |
|------|------|------|
| -O0 | ìµœì í™” ì—†ìŒ | ë””ë²„ê¹… |
| -O1 | ê¸°ë³¸ ìµœì í™” | ë¹ ë¥¸ ì»´íŒŒì¼ |
| -O2 | ê¶Œì¥ ìµœì í™” | ì¼ë°˜ì  ì‚¬ìš© |
| -O3 | ê³µê²©ì  ìµœì í™” | ìµœëŒ€ ì„±ëŠ¥ |
| -Os | í¬ê¸° ìµœì í™” | ì„ë² ë””ë“œ |
| -Og | ë””ë²„ê·¸ ìµœì í™” | ë””ë²„ê¹…+ì•½ê°„ì˜ ìµœì í™” |

## 2. ì£¼ìš” ìµœì í™” ê¸°ë²•ë“¤

### 2.1 ìƒìˆ˜ í´ë”© (Constant Folding)

ì»´íŒŒì¼ ì‹œì ì— ê³„ì‚° ê°€ëŠ¥í•œ ê²ƒì€ ë¯¸ë¦¬ ê³„ì‚°í•©ë‹ˆë‹¤:

```c
// ì›ë³¸ ì½”ë“œ
int get_buffer_size() {
    return 1024 * 1024 * 16;  // 16MB
}

// ìµœì í™” í›„ (ì–´ì…ˆë¸”ë¦¬ ì˜ì‚¬ ì½”ë“œ)
get_buffer_size:
    mov eax, 16777216  // ì´ë¯¸ ê³„ì‚°ëœ ê°’
    ret
```

ë” ë³µì¡í•œ ì˜ˆ:

```c
// ì›ë³¸
double calculate() {
    double pi = 3.14159265359;
    double radius = 10.0;
    return 2 * pi * radius;
}

// ìµœì í™” í›„
double calculate() {
    return 62.83185307179586;  // ì»´íŒŒì¼ ì‹œì ì— ê³„ì‚°
}
```

### 2.2 ì£½ì€ ì½”ë“œ ì œê±° (Dead Code Elimination)

ì‹¤í–‰ë˜ì§€ ì•Šê±°ë‚˜ ê²°ê³¼ê°€ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì½”ë“œë¥¼ ì œê±°í•©ë‹ˆë‹¤:

```c
// ì›ë³¸ ì½”ë“œ
int process(int x) {
    int unused = x * 100;     // ì‚¬ìš© ì•ˆ ë¨

    if (0) {                  // ì ˆëŒ€ ì‹¤í–‰ ì•ˆ ë¨
        printf("Never, ");
    }

    int result = x + 1;
    result = x + 2;           // ì´ì „ ê°’ ë®ì–´ì”€

    return result;
}

// ìµœì í™” í›„
int process(int x) {
    return x + 2;
}
```

### 2.3 í•¨ìˆ˜ ì¸ë¼ì´ë‹ (Function Inlining)

ì‘ì€ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ ìœ„ì¹˜ì— ì§ì ‘ ì‚½ì…í•©ë‹ˆë‹¤:

```c
// ì›ë³¸ ì½”ë“œ
inline int square(int x) {
    return x * x;
}

int calculate(int a, int b) {
    return square(a) + square(b);
}

// ìµœì í™” í›„
int calculate(int a, int b) {
    return (a * a) + (b * b);  // í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì œê±°
}
```

ì¸ë¼ì´ë‹ì˜ íš¨ê³¼:

```mermaid
graph LR
    subgraph "ì¸ë¼ì´ë‹ ì „"
        C1["calculate] -->|call| S1[square]
        S1 -->|return| C1
        C1 -->|call| S2[square"]
        S2 -->|return| C1
    end

    subgraph "ì¸ë¼ì´ë‹ í›„"
        C2["calculate
ì§ì ‘ ê³„ì‚°"]
    end

    style C2 fill:#4CAF50
```

### 2.4 ë£¨í”„ ìµœì í™”

#### ë£¨í”„ ì–¸ë¡¤ë§ (Loop Unrolling)

```c
// ì›ë³¸ ì½”ë“œ
for (int i = 0; i < 4; i++) {
    sum += array[i];
}

// ì–¸ë¡¤ë§ í›„
sum += array[0];
sum += array[1];
sum += array[2];
sum += array[3];
// ë£¨í”„ ì œì–´ ì˜¤ë²„í—¤ë“œ ì œê±°
```

#### ë£¨í”„ ë¶ˆë³€ ì½”ë“œ ì´ë™ (Loop-Invariant Code Motion)

```c
// ì›ë³¸ ì½”ë“œ
for (int i = 0; i < n; i++) {
    int constant = x * y;  // ë£¨í”„ë§ˆë‹¤ ê°™ì€ ê°’
    result[i] = array[i] + constant;
}

// ìµœì í™” í›„
int constant = x * y;  // ë£¨í”„ ë°–ìœ¼ë¡œ ì´ë™
for (int i = 0; i < n; i++) {
    result[i] = array[i] + constant;
}
```

#### ë£¨í”„ ìœµí•© (Loop Fusion)

```c
// ì›ë³¸ ì½”ë“œ
for (int i = 0; i < n; i++) {
    a[i] = b[i] + 1;
}
for (int i = 0; i < n; i++) {
    c[i] = a[i] * 2;
}

// ìœµí•© í›„
for (int i = 0; i < n; i++) {
    a[i] = b[i] + 1;
    c[i] = a[i] * 2;  // ìºì‹œ ì§€ì—­ì„± í–¥ìƒ
}
```

### 2.5 ê³µí†µ ë¶€ë¶„ì‹ ì œê±° (Common Subexpression Elimination)

ê°™ì€ ê³„ì‚°ì„ ë°˜ë³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:

```c
// ì›ë³¸ ì½”ë“œ
int calculate(int x, int y) {
    int a = (x + y) * 2;
    int b = (x + y) * 3;
    int c = (x + y) / 2;
    return a + b + c;
}

// ìµœì í™” í›„
int calculate(int x, int y) {
    int temp = x + y;  // í•œ ë²ˆë§Œ ê³„ì‚°
    int a = temp * 2;
    int b = temp * 3;
    int c = temp / 2;
    return a + b + c;
}
```

## 3. ê³ ê¸‰ ìµœì í™” ê¸°ë²•

### 3.1 ë²¡í„°í™” (Vectorization)

SIMD ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ë°ì´í„°ë¥¼ ë™ì‹œ ì²˜ë¦¬:

```c
// ì›ë³¸ ì½”ë“œ
for (int i = 0; i < 1024; i++) {
    c[i] = a[i] + b[i];
}

// ë²¡í„°í™” í›„ (ì˜ì‚¬ ì½”ë“œ)
for (int i = 0; i < 1024; i += 4) {
    // 4ê°œì”© ë™ì‹œ ì²˜ë¦¬
    vector_add(c + i, a + i, b + i, 4);
}
```

ë²¡í„°í™” íš¨ê³¼:

```mermaid
graph TD
    subgraph "ìŠ¤ì¹¼ë¼ ì²˜ë¦¬"
        A1["a[0]"] --> P1[+] --> C1["c[0]"]
        A2["a[1]"] --> P2[+] --> C2["c[1]"]
        A3["a[2]"] --> P3[+] --> C3["c[2]"]
        A4["a[3]"] --> P4[+] --> C4["c[3]"]
    end

    subgraph "ë²¡í„° ì²˜ë¦¬ (SIMD)"
        AV["a[0:3]"] --> PV["Vector +"] --> CV["c[0:3]"]
    end

    style PV fill:#4CAF50
```

### 3.2 ë¶„ê¸° ì˜ˆì¸¡ ìµœì í™”

ì¡°ê±´ë¬¸ì„ ìµœì í™”í•˜ì—¬ íŒŒì´í”„ë¼ì¸ íš¨ìœ¨ì„± í–¥ìƒ:

```c
// ì›ë³¸ ì½”ë“œ
for (int i = 0; i < n; i++) {
    if (likely(array[i] > 0)) {  // ëŒ€ë¶€ë¶„ ì°¸
        positive_count++;
    } else {
        negative_count++;
    }
}

// ì»´íŒŒì¼ëŸ¬ íŒíŠ¸ ì‚¬ìš©
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
```

### 3.3 í…Œì¼ ì½œ ìµœì í™” (Tail Call Optimization)

ì¬ê·€ë¥¼ ë°˜ë³µë¬¸ìœ¼ë¡œ ë³€í™˜:

```c
// ì›ë³¸ ì¬ê·€ ì½”ë“œ
int factorial(int n, int acc) {
    if (n <= 1) return acc;
    return factorial(n - 1, n * acc);  // í…Œì¼ ì½œ
}

// ìµœì í™” í›„ (ë°˜ë³µë¬¸ìœ¼ë¡œ ë³€í™˜)
int factorial(int n, int acc) {
    while (n > 1) {
        acc = n * acc;
        n = n - 1;
    }
    return acc;
}
```

ìŠ¤íƒ ì‚¬ìš©ëŸ‰ ë¹„êµ:

```text
ì¬ê·€ ë²„ì „:              ìµœì í™” ë²„ì „:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚factorial â”‚ n=5       â”‚factorial â”‚ n=5
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚factorial â”‚ n=4       (ìŠ¤íƒ í”„ë ˆì„ 1ê°œë§Œ ì‚¬ìš©)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚factorial â”‚ n=3
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚factorial â”‚ n=2
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚factorial â”‚ n=1
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 4. ìµœì í™” ë ˆë²¨ë³„ ì°¨ì´

### 4.1 ì‹¤ì œ ì˜ˆì œë¡œ ë³´ëŠ” ì°¨ì´

ê°„ë‹¨í•œ í•¨ìˆ˜ë¥¼ ê° ìµœì í™” ë ˆë²¨ë¡œ ì»´íŒŒì¼:

```c
// test.c
int sum_array(int* arr, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    return sum;
}
```

#### -O0 (ìµœì í™” ì—†ìŒ)

```assembly
sum_array:
    push   rbp
    mov    rbp, rsp
    mov    QWORD PTR [rbp-24], rdi  ; arr ì €ì¥
    mov    DWORD PTR [rbp-28], esi  ; n ì €ì¥
    mov    DWORD PTR [rbp-4], 0     ; sum = 0
    mov    DWORD PTR [rbp-8], 0     ; i = 0
.L3:
    mov    eax, DWORD PTR [rbp-8]   ; i ë¡œë“œ
    cmp    eax, DWORD PTR [rbp-28]  ; i < n ë¹„êµ
    jge    .L2
    ; ... ë³µì¡í•œ ë©”ëª¨ë¦¬ ì ‘ê·¼ ...
    add    DWORD PTR [rbp-4], eax   ; sum += arr[i]
    add    DWORD PTR [rbp-8], 1     ; i++
    jmp    .L3
.L2:
    mov    eax, DWORD PTR [rbp-4]
    pop    rbp
    ret
```

#### -O2 (ê¶Œì¥ ìµœì í™”)

```assembly
sum_array:
    test   esi, esi          ; n == 0?
    jle    .L4
    lea    eax, [rsi-1]      ; ë£¨í”„ ì¤€ë¹„
    xor    edx, edx          ; sum = 0 (ë ˆì§€ìŠ¤í„°)
    xor    ecx, ecx          ; i = 0 (ë ˆì§€ìŠ¤í„°)
.L3:
    add    edx, DWORD PTR [rdi+rcx*4]  ; sum += arr[i]
    inc    rcx                          ; i++
    cmp    rax, rcx
    jne    .L3
    mov    eax, edx
    ret
.L4:
    xor    eax, eax          ; return 0
    ret
```

#### -O3 (ê³µê²©ì  ìµœì í™”, ë²¡í„°í™” í¬í•¨)

```assembly
sum_array:
    ; SIMD ëª…ë ¹ì–´ ì‚¬ìš©
    vpxor   xmm0, xmm0, xmm0    ; ë²¡í„° ë ˆì§€ìŠ¤í„° ì´ˆê¸°í™”
    ; ... 4ê°œì”© ë³‘ë ¬ ì²˜ë¦¬ ...
    vpaddd  xmm0, xmm0, XMMWORD PTR [rdi+rax*4]
    ; ... ë‚˜ë¨¸ì§€ ì²˜ë¦¬ ...
```

### 4.2 ì„±ëŠ¥ ë¹„êµ

```text
ë²¤ì¹˜ë§ˆí¬ ê²°ê³¼ (1,000,000 ìš”ì†Œ ë°°ì—´):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë ˆë²¨    â”‚ ì‹¤í–‰ ì‹œê°„   â”‚ ìƒëŒ€ ì„±ëŠ¥    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ -O0     â”‚ 4.2ms      â”‚ 1.0x        â”‚
â”‚ -O1     â”‚ 2.1ms      â”‚ 2.0x        â”‚
â”‚ -O2     â”‚ 1.3ms      â”‚ 3.2x        â”‚
â”‚ -O3     â”‚ 0.8ms      â”‚ 5.2x        â”‚
â”‚ -Os     â”‚ 1.5ms      â”‚ 2.8x        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 5. ìµœì í™”ì˜ ë¶€ì‘ìš©

### 5.1 ì •ë°€ë„ ë¬¸ì œ

ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚° ìˆœì„œ ë³€ê²½:

```c
// ì›ë³¸ ì½”ë“œ
float calculate(float a, float b, float c) {
    return (a + b) + c;
}

// ìµœì í™”ë¡œ ìˆœì„œ ë³€ê²½ ê°€ëŠ¥
float calculate_opt(float a, float b, float c) {
    return a + (b + c);  // ê²°ê³¼ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ!
}

// ì˜ˆ: a = 1e30, b = -1e30, c = 1.0
// (a + b) + c = 0.0 + 1.0 = 1.0
// a + (b + c) = 1e30 + (-1e30 + 1.0) = 1e30 - 1e30 = 0.0
```

### 5.2 Undefined Behavior

ì»´íŒŒì¼ëŸ¬ëŠ” undefined behaviorê°€ ì—†ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤:

```c
// ìœ„í—˜í•œ ì½”ë“œ
int dangerous(int x) {
    int result = x + 1;
    if (x == INT_MAX) {  // ì˜¤ë²„í”Œë¡œìš° ì²´í¬
        return -1;
    }
    return result;
}

// ì»´íŒŒì¼ëŸ¬ ìµœì í™” í›„
int dangerous_opt(int x) {
    return x + 1;  // ì²´í¬ ì œê±°! (UBëŠ” ì—†ë‹¤ê³  ê°€ì •)
}
```

### 5.3 ë©”ëª¨ë¦¬ ì¬ì •ë ¬

ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë¬¸ì œ:

```c
// ì›ë³¸ ì½”ë“œ
int data = 0;
int flag = 0;

// Thread 1
void writer() {
    data = 42;
    flag = 1;  // data ì¤€ë¹„ ì™„ë£Œ ì‹ í˜¸
}

// Thread 2
void reader() {
    if (flag == 1) {
        use(data);  // data = 42 ê¸°ëŒ€
    }
}

// ìµœì í™”ë¡œ ìˆœì„œ ë³€ê²½ ê°€ëŠ¥!
void writer_opt() {
    flag = 1;  // ìˆœì„œ ë°”ë€œ!
    data = 42;
}
```

í•´ê²°: ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ì™€ Atomic Operations

```c
#include <stdatomic.h>

// C11 atomicì„ ì‚¬ìš©í•œ ì•ˆì „í•œ ë²„ì „
atomic_int data = ATOMIC_VAR_INIT(0);
atomic_int flag = ATOMIC_VAR_INIT(0);

void writer_safe() {
    atomic_store_explicit(&data, 42, memory_order_relaxed);
    atomic_store_explicit(&flag, 1, memory_order_release);  // release barrier
}

void reader_safe() {
    if (atomic_load_explicit(&flag, memory_order_acquire) == 1) {  // acquire barrier
        int value = atomic_load_explicit(&data, memory_order_relaxed);
        use(value);  // data = 42 ë³´ì¥ë¨
    }
}

// ë˜ëŠ” ì „í†µì ì¸ ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ ì‚¬ìš©
void writer_traditional() {
    data = 42;
    __sync_synchronize();  // full memory barrier
    flag = 1;
}
```

**ë©”ëª¨ë¦¬ ìˆœì„œ ë³´ì¥ (Memory Ordering):**

- `memory_order_relaxed`: ìˆœì„œ ë³´ì¥ ì—†ìŒ, ì›ìì„±ë§Œ ë³´ì¥
- `memory_order_acquire`: ì´í›„ ë©”ëª¨ë¦¬ ì ‘ê·¼ì´ ì•ìœ¼ë¡œ ì´ë™í•˜ì§€ ì•ŠìŒ
- `memory_order_release`: ì´ì „ ë©”ëª¨ë¦¬ ì ‘ê·¼ì´ ë’¤ë¡œ ì´ë™í•˜ì§€ ì•ŠìŒ
- `memory_order_seq_cst`: ìˆœì°¨ ì¼ê´€ì„± (ê¸°ë³¸ê°’)

## 6. ì»´íŒŒì¼ëŸ¬ ë„ì›€ë°›ê¸°

### 6.1 ì»´íŒŒì¼ëŸ¬ íŒíŠ¸

```c
// 1. inline íŒíŠ¸
inline int small_function(int x) {
    return x * 2;
}

// 2. ë¶„ê¸° ì˜ˆì¸¡ íŒíŠ¸
if (__builtin_expect(error_condition, 0)) {  // unlikely
    handle_error();
}

// 3. ì •ë ¬ íŒíŠ¸
struct __attribute__((aligned(64))) cache_line {
    int data[16];  // ìºì‹œ ë¼ì¸ ì •ë ¬
};

// 4. ìˆœìˆ˜ í•¨ìˆ˜ íŒíŠ¸
__attribute__((pure))
int pure_function(int x) {
    return x * x;  // ë¶€ì‘ìš© ì—†ìŒ
}

// 5. restrict í¬ì¸í„°
void copy(int* restrict dst, const int* restrict src, int n) {
    // dstì™€ srcê°€ ê²¹ì¹˜ì§€ ì•ŠìŒì„ ë³´ì¥
    for (int i = 0; i < n; i++) {
        dst[i] = src[i];
    }
}
```

### 6.2 í”„ë¡œíŒŒì¼ ê¸°ë°˜ ìµœì í™” (PGO)

ì‹¤í–‰ í”„ë¡œíŒŒì¼ì„ ìˆ˜ì§‘í•˜ì—¬ ìµœì í™”:

```bash
# 1ë‹¨ê³„: í”„ë¡œíŒŒì¼ ìˆ˜ì§‘ìš© ë¹Œë“œ
gcc -fprofile-generate program.c -o program

# 2ë‹¨ê³„: ëŒ€í‘œì ì¸ ì›Œí¬ë¡œë“œ ì‹¤í–‰
./program < typical_input.txt

# 3ë‹¨ê³„: í”„ë¡œíŒŒì¼ ê¸°ë°˜ ì¬ì»´íŒŒì¼
gcc -fprofile-use program.c -o program_optimized
```

PGO íš¨ê³¼:

```mermaid
graph LR
    subgraph "ì¼ë°˜ ìµœì í™”"
        C1["ì½”ë“œ"] --> O1["ì •ì  ë¶„ì„"] --> B1["ë°”ì´ë„ˆë¦¬"]
    end

    subgraph "PGO"
        C2["ì½”ë“œ"] --> P["í”„ë¡œíŒŒì¼
ì‹¤í–‰"] --> O2["ë™ì  ë¶„ì„"] --> B2["ìµœì í™”ëœ
ë°”ì´ë„ˆë¦¬"]
    end

    style P fill:#FFE082
    style B2 fill:#4CAF50
```

## 7. ì‹¤ì „: ìµœì í™” ë¶„ì„

### 7.1 ì»´íŒŒì¼ëŸ¬ ì¶œë ¥ ë¶„ì„

```bash
# ìµœì í™” ë¦¬í¬íŠ¸ ìƒì„±
gcc -O2 -fopt-info-vec-all program.c

# ì¶œë ¥ ì˜ˆ:
program.c:10:5: optimized: loop vectorized using 32 byte vectors
program.c:15:8: note: not vectorized: not enough data-refs
program.c:20:3: optimized: loop unrolled 4 times

# ì–´ì…ˆë¸”ë¦¬ ìƒì„±
gcc -S -O2 -fverbose-asm program.c

# ìµœì í™” í†µê³„
gcc -O2 -fdump-statistics program.c
```

### 7.2 ìµœì í™” ì „í›„ ë¹„êµ

ì‹¤ì œ ì½”ë“œ ì˜ˆì œ:

```c
// matrix_multiply.c
void matrix_multiply(double* C, const double* A, const double* B, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            double sum = 0.0;
            for (int k = 0; k < n; k++) {
                sum += A[i*n + k] * B[k*n + j];
            }
            C[i*n + j] = sum;
        }
    }
}
```

ìµœì í™” ê¸°ë²• ì ìš©:

```c
// ìºì‹œ ì¹œí™”ì  ë²„ì „ (íƒ€ì¼ë§)
void matrix_multiply_tiled(double* C, const double* A, const double* B, int n) {
    const int TILE = 64;

    for (int i0 = 0; i0 < n; i0 += TILE) {
        for (int j0 = 0; j0 < n; j0 += TILE) {
            for (int k0 = 0; k0 < n; k0 += TILE) {
                // íƒ€ì¼ ë‚´ë¶€ ì²˜ë¦¬
                for (int i = i0; i < min(i0+TILE, n); i++) {
                    for (int j = j0; j < min(j0+TILE, n); j++) {
                        double sum = C[i*n + j];
                        for (int k = k0; k < min(k0+TILE, n); k++) {
                            sum += A[i*n + k] * B[k*n + j];
                        }
                        C[i*n + j] = sum;
                    }
                }
            }
        }
    }
}
```

ì„±ëŠ¥ ì°¨ì´:

```text
í–‰ë ¬ í¬ê¸°: 1024x1024
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë²„ì „         â”‚ ì‹œê°„(ms) â”‚ ìºì‹œ ë¯¸ìŠ¤   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ê¸°ë³¸ (-O0)   â”‚ 2850     â”‚ 65M        â”‚
â”‚ ê¸°ë³¸ (-O2)   â”‚ 920      â”‚ 64M        â”‚
â”‚ ê¸°ë³¸ (-O3)   â”‚ 680      â”‚ 63M        â”‚
â”‚ íƒ€ì¼ë§ (-O2) â”‚ 340      â”‚ 8M         â”‚
â”‚ íƒ€ì¼ë§ (-O3) â”‚ 280      â”‚ 7M         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 8. ìµœì í™” ê°€ì´ë“œë¼ì¸

### 8.1 DO - ê¶Œì¥ ì‚¬í•­

1.**ì¸¡ì •ì´ ë¨¼ì €**: ì¶”ì¸¡í•˜ì§€ ë§ê³  í”„ë¡œíŒŒì¼ë§ë¶€í„°
2.**ì•Œê³ ë¦¬ì¦˜ì´ ë¨¼ì €**: O(nÂ²) â†’ O(n log n)ì´ ìµœìš°ì„ 
3.**ì»´íŒŒì¼ëŸ¬ ë¯¿ê¸°**: ë‹¨ìˆœí•œ ìµœì í™”ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë” ì˜í•´ìš”
4.**ê°€ë…ì„± ìš°ì„ **: ì½ê¸° ì‰¬ìš´ ì½”ë“œê°€ ìµœì í™”í•˜ê¸°ë„ ì‰¬ì›Œìš”
5.**ì ì ˆí•œ ë ˆë²¨**: ëŒ€ë¶€ë¶„ -O2ë¡œ ì¶©ë¶„í•´ìš”

### 8.2 DON'T - í”¼í•´ì•¼ í•  ê²ƒ

1.**ì¡°ê¸° ìµœì í™”**: "Premature optimization is the root of all evil"
2.**ê³¼ë„í•œ ìˆ˜ë™ ìµœì í™”**: ì»´íŒŒì¼ëŸ¬ë¥¼ ë°©í•´í•  ìˆ˜ ìˆìŒ
3.**UB ì˜ì¡´**: Undefined behaviorì— ì˜ì¡´í•˜ëŠ” ì½”ë“œ
4.**ì´ì‹ì„± ë¬´ì‹œ**: íŠ¹ì • ì»´íŒŒì¼ëŸ¬/ì•„í‚¤í…ì²˜ ì „ìš© ì½”ë“œ
5.**ë§¹ëª©ì  -O3**: í•­ìƒ ë¹ ë¥¸ ê²ƒì€ ì•„ë‹˜

## 9. ì •ë¦¬: ì»´íŒŒì¼ëŸ¬ ìµœì í™”ì˜ í•µì‹¬

### ìµœì í™”ë€?

-**ì •ì˜**: í”„ë¡œê·¸ë¨ì˜ ì˜ë¯¸ë¥¼ ìœ ì§€í•˜ë©´ì„œ ì„±ëŠ¥ì„ ê°œì„ í•˜ëŠ” ë³€í™˜
-**ëª©ì **: ì‹¤í–‰ ì†ë„ í–¥ìƒ, ë©”ëª¨ë¦¬ ì‚¬ìš© ê°ì†Œ, ì „ë ¥ íš¨ìœ¨ ê°œì„ 
-**ì œì•½**: í”„ë¡œê·¸ë¨ì˜ ê´€ì°° ê°€ëŠ¥í•œ ë™ì‘ì€ ë³€ê²½í•˜ì§€ ì•ŠìŒ

### ì™œ ì¤‘ìš”í•œê°€?

1.**ë¬´ë£Œ ì„±ëŠ¥ í–¥ìƒ**: ì½”ë“œ ë³€ê²½ ì—†ì´ 2-10ë°° ì„±ëŠ¥ ê°œì„ 
2.**í•˜ë“œì›¨ì–´ í™œìš©**: SIMD, ìºì‹œ, íŒŒì´í”„ë¼ì¸ ìµœì  í™œìš©
3.**ê°œë°œ ìƒì‚°ì„±**: ìµœì í™”ëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ, ë¡œì§ì€ ê°œë°œìê°€

### ê¸°ì–µí•´ì•¼ í•  ì 

- ì»´íŒŒì¼ëŸ¬ëŠ” ê°•ë ¥í•˜ì§€ë§Œ ë§ŒëŠ¥ì´ ì•„ë‹ˆì—ìš”
- ìµœì í™” ë ˆë²¨ì— ë”°ë¼ ë‹¤ë¥¸ ê¸°ë²•ì´ ì ìš©ë¼ìš”
- ì•Œê³ ë¦¬ì¦˜ ê°œì„ ì´ ì»´íŒŒì¼ëŸ¬ ìµœì í™”ë³´ë‹¤ ì¤‘ìš”í•´ìš”
- ìµœì í™”ëŠ” ë•Œë¡œ ì˜ˆìƒì¹˜ ëª»í•œ ë¶€ì‘ìš©ì„ ê°€ì ¸ì™€ìš”
- ì¸¡ì • ì—†ëŠ” ìµœì í™”ëŠ” ê·¸ëƒ¥ ì¶”ì¸¡ì¼ ë¿ì´ì£ 

## ë‹¤ìŒ ì¥ ì˜ˆê³ 

Chapter 1ì„ ë§ˆì¹˜ê³ , [Chapter 2: ë©”ëª¨ë¦¬ ì•„í‚¤í…ì²˜](../chapter-03-memory-system/index.md)ì—ì„œëŠ”**í”„ë¡œê·¸ë¨ ë¡œë”©ê³¼ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ**ì„ ë‹¤ë£¹ë‹ˆë‹¤:

- í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ëŠ” ì–´ë–»ê²Œ êµ¬ì„±ë˜ëŠ”ê°€?
- ìŠ¤íƒê³¼ í™ì€ ì–´ë–»ê²Œ ìë¼ëŠ”ê°€?
- ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ëŠ” ì™œ ë°œìƒí•˜ëŠ”ê°€?
- ê°€ìƒ ë©”ëª¨ë¦¬ëŠ” ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€?

ì»´íŒŒì¼ê³¼ ë§í‚¹ì„ ê±°ì³ ë§Œë“¤ì–´ì§„ í”„ë¡œê·¸ë¨ì´ ì‹¤ì œë¡œ ë©”ëª¨ë¦¬ì—ì„œ ì–´ë–»ê²Œ ì‚´ì•„ ìˆ¨ì‰¬ëŠ”ì§€, ê·¸ í¥ë¯¸ë¡œìš´ ì„¸ê³„ë¡œ í•¨ê»˜ ë– ë‚˜ë´…ì‹œë‹¤.

## ğŸ“š ê´€ë ¨ ë¬¸ì„œ

### ğŸ“– í˜„ì¬ ë¬¸ì„œ ì •ë³´

-**ë‚œì´ë„**: INTERMEDIATE
-**ì£¼ì œ**: ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë°
-**ì˜ˆìƒ ì‹œê°„**: 3-4ì‹œê°„

### ğŸ¯ í•™ìŠµ ê²½ë¡œ

- [ğŸ“š INTERMEDIATE ë ˆë²¨ ì „ì²´ ë³´ê¸°](../learning-paths/intermediate/)
- [ğŸ  ë©”ì¸ í•™ìŠµ ê²½ë¡œ](../learning-paths/)
- [ğŸ“‹ ì „ì²´ ê°€ì´ë“œ ëª©ë¡](../README.md)

### ğŸ“‚ ê°™ì€ ì±•í„° (chapter-01-compiler-linker)

- [5.1: ì»´íŒŒì¼ì€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€](./05-01-01-compilation.md)
- [5.2: ë§í‚¹ì€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€](./05-02-01-linking.md)
- [5.3: ë¡œë”©ê³¼ ì‹¤í–‰ì€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€](./05-03-01-loading-execution.md)
- [5.5: ë¹Œë“œ ì‹œìŠ¤í…œ ë””ë²„ê¹… - "ì™œ ë¹Œë“œê°€ ì´ë ‡ê²Œ ëŠë¦¬ì§€?"](./05-05-01-build-debugging.md)
- [5.6: ë§ì»¤ ì—ëŸ¬ í•´ê²° - "undefined referenceê°€ ê³„ì† ë‚˜ìš”"](./05-05-02-linking-debugging.md)

### ğŸ·ï¸ ê´€ë ¨ í‚¤ì›Œë“œ

`compiler-optimization`, `performance`, `vectorization`, `loop-optimization`, `simd`

### â­ï¸ ë‹¤ìŒ ë‹¨ê³„ ê°€ì´ë“œ

- ì‹¤ë¬´ ì ìš©ì„ ì—¼ë‘ì— ë‘ê³  í”„ë¡œì íŠ¸ì— ì ìš©í•´ë³´ì„¸ìš”
- ê´€ë ¨ ë„êµ¬ë“¤ì„ ì§ì ‘ ì‚¬ìš©í•´ë³´ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤
