# 멀티스레드 스택 메모리의 진실: 800MB의 함정

**Tags:** `#memory` `#multithreading` `#stack` `#virtual-memory` `#linux` `#performance`

## 들어가며

"스레드 100개 만들면 스택만 800MB 사용하는 거 아니야?", "메인 스레드는 왜 특별 취급받아?", "가상 메모리가 뭔데 실제 메모리랑 다르다는 거야?" 멀티스레드 프로그래밍을 하다 보면 이런 의문이 생깁니다. 오늘은 스레드 스택의 실제 동작 방식과 흔한 오해를 파헤쳐보겠습니다.

## 멀티스레드 메모리 구조의 실체

먼저 프로세스의 가상 메모리 공간에서 스레드들의 스택이 어떻게 배치되는지 봅시다:

```
Process Virtual Memory (멀티스레드):
┌─────────────────────────────────────┐ 0xFFFFFFFF
│         Kernel Space                │
├─────────────────────────────────────┤
│    Main Thread Stack                │ ← 메인 스레드 (특별한 위치)
│    ┌─────────────────────┐          │
│    │ Environment vars    │          │
│    │ Program arguments   │          │
│    │ Stack frames        │          │
│    │         ↓           │          │
│    └─────────────────────┘          │
│    [guard page]                     │
├─────────────────────────────────────┤
│         Random Gap                  │
├─────────────────────────────────────┤
│    Memory Mapped Region              │
│    ┌──────────────────┐             │
│    │ Thread 2 Stack   │ 8MB         │ ← 추가 스레드들
│    │ [guard page]     │             │   (mmap으로 할당)
│    ├──────────────────┤             │
│    │ Thread 3 Stack   │ 8MB         │
│    │ [guard page]     │             │
│    ├──────────────────┤             │
│    │ Thread 4 Stack   │ 8MB         │
│    │ [guard page]     │             │
│    └──────────────────┘             │
│         Shared Libraries            │
├─────────────────────────────────────┤
│         Heap (모든 스레드 공유)      │
├─────────────────────────────────────┤
│         Data & BSS                  │
├─────────────────────────────────────┤
│         Text (Code)                 │
└─────────────────────────────────────┘ 0x00000000
```

## 메인 스레드가 특별한 이유

메인 스레드는 여러 면에서 특별합니다:

### 1. 프로세스와 생명주기를 공유

```c
#include <pthread.h>
#include <unistd.h>

void* worker_thread(void* arg) {
    sleep(10);
    printf("Worker still running...\n");
    return NULL;
}

int main(int argc, char* argv[], char* envp[]) {
    pthread_t thread;
    pthread_create(&thread, NULL, worker_thread, NULL);
    
    // 메인 스레드가 종료하면?
    return 0;  // 프로세스 전체 종료! Worker도 강제 종료
}

// 반대로 worker 스레드가 죽어도 프로세스는 계속 실행
```

### 2. 특별한 초기화 데이터

```c
int main(int argc, char* argv[], char* envp[]) {
    // 메인 스레드 스택에는 특별한 데이터가 있음
    
    // 1. 프로그램 인자
    for (int i = 0; i < argc; i++) {
        printf("argv[%d]: %s at %p\n", i, argv[i], argv[i]);
    }
    
    // 2. 환경 변수
    for (char** env = envp; *env != NULL; env++) {
        printf("env: %s at %p\n", *env, *env);
    }
    
    // 3. Auxiliary Vector (시스템 정보)
    // 스택 최상단에 위치
}

// 메인 스레드 스택 레이아웃:
// ┌─────────────────┐ High Address
// │ Auxiliary Vector│ (시스템 정보)
// │ Environment     │ (PATH=..., HOME=...)
// │ Arguments       │ (argv[0], argv[1]...)
// │ argc            │
// │ Stack frames    │
// │       ↓         │
// └─────────────────┘
```

### 3. 전통적 스택 위치

```c
void compare_stack_locations() {
    pthread_t thread;
    int main_stack_var;
    
    printf("Main thread stack: %p\n", &main_stack_var);
    // 0x7fffffffXXXX (높은 주소, 스택 영역)
    
    pthread_create(&thread, NULL, [](void* arg) -> void* {
        int worker_stack_var;
        printf("Worker thread stack: %p\n", &worker_stack_var);
        // 0x7f8a2c7fXXXX (중간 주소, mmap 영역)
        return NULL;
    }, NULL);
}
```

## 800MB의 함정: 가상 vs 물리 메모리

이제 핵심 질문입니다: **스레드 100개 = 800MB 메모리?**

### 실험: 100개 스레드 생성

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/resource.h>

void print_memory_usage(const char* label) {
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
    
    FILE* status = fopen("/proc/self/status", "r");
    char line[256];
    long vmsize = 0, vmrss = 0;
    
    while (fgets(line, sizeof(line), status)) {
        if (sscanf(line, "VmSize: %ld kB", &vmsize) == 1) continue;
        if (sscanf(line, "VmRSS: %ld kB", &vmrss) == 1) continue;
    }
    fclose(status);
    
    printf("%s:\n", label);
    printf("  Virtual Memory: %ld MB\n", vmsize / 1024);
    printf("  Physical Memory (RSS): %ld MB\n", vmrss / 1024);
}

void* minimal_thread(void* arg) {
    // 거의 아무것도 안 함
    pause();  // 시그널 대기
    return NULL;
}

int main() {
    print_memory_usage("Before creating threads");
    
    pthread_t threads[100];
    for (int i = 0; i < 100; i++) {
        pthread_create(&threads[i], NULL, minimal_thread, NULL);
    }
    
    sleep(1);  // 스레드 생성 대기
    print_memory_usage("After creating 100 threads");
    
    return 0;
}
```

### 실행 결과

```bash
$ ./thread_test

Before creating threads:
  Virtual Memory: 5 MB
  Physical Memory (RSS): 1 MB

After creating 100 threads:
  Virtual Memory: 825 MB      # 5 + (100 * 8MB) + α
  Physical Memory (RSS): 10 MB  # 실제로는 10MB만!
```

**놀라운 사실: 가상 메모리는 825MB지만, 실제 물리 메모리는 10MB만 사용!**

## Demand Paging의 마법

Linux는 "게으른 할당(Lazy Allocation)"을 사용합니다:

```
스레드 생성 시 메모리 할당 과정:

Step 1: pthread_create() 호출
├─> mmap(8MB, ...) 
└─> 가상 주소 공간만 예약 (물리 메모리 X)

Step 2: 스택 첫 접근
├─> Page Fault 발생
├─> 커널이 물리 페이지 1개(4KB) 할당
└─> 페이지 테이블 업데이트

Step 3: 스택 추가 사용
├─> 필요한 만큼만 물리 페이지 추가
└─> 대부분 스레드는 몇 KB만 사용

┌──────────────────────┐
│   Thread Stack       │
│   Virtual: 8192 KB   │ ← 가상 메모리 8MB
│ ┌──────────────────┐ │
│ │ Physical: 4 KB   │ │ ← 실제 메모리 4KB!
│ ├──────────────────┤ │
│ │                  │ │
│ │   Not Mapped     │ │ ← 물리 메모리 없음
│ │   (8188 KB)      │ │   (접근하면 Page Fault)
│ │                  │ │
│ └──────────────────┘ │
└──────────────────────┘
```

### 실제 메모리 매핑 확인

```bash
# 프로세스의 스레드 스택 확인
$ cat /proc/&lt;pid&gt;/smaps | grep -B1 -A3 "stack"

7f8a2c000000-7f8a2c800000 rw-p 00000000 00:00 0    [stack:12345]
Size:               8192 kB   # 가상 크기: 8MB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                   8 kB   # 실제 사용: 8KB만!
Pss:                   8 kB
Referenced:            8 kB
Anonymous:             8 kB
```

## 언제 실제로 문제가 될까?

### 1. 모든 스레드가 스택을 많이 사용할 때

```c
void* heavy_stack_user(void* arg) {
    // 재귀 호출로 스택 사용
    void recursive(int depth) {
        char large_array[4096];  // 4KB 로컬 배열
        
        // 배열 실제 사용 (Page Fault 유발)
        memset(large_array, 0, sizeof(large_array));
        
        if (depth > 0) {
            recursive(depth - 1);
        }
    }
    
    recursive(1000);  // 4MB 스택 사용!
    return NULL;
}

// 이제 100개 스레드 = 실제 400MB 사용!
```

### 2. 가상 메모리 주소 공간 고갈 (32비트)

```c
// 32비트 시스템: 주소 공간 3GB (사용자 공간)
// 스레드당 8MB → 최대 ~380개 스레드

#ifdef __i386__
    #define MAX_THREADS (3072 / 8)  // 384개
#else
    #define MAX_THREADS 10000       // 64비트는 충분
#endif
```

### 3. 커널 리소스 제한

```bash
# 시스템 제한 확인
$ cat /proc/sys/kernel/threads-max
63704  # 시스템 전체 최대 스레드

$ cat /proc/sys/vm/max_map_count  
65530  # 프로세스당 최대 메모리 맵

$ ulimit -u
31852  # 사용자당 최대 프로세스/스레드
```

## Guard Page: 스택 오버플로우 방지

각 스택 사이에는 보호 페이지가 있습니다:

```c
void demonstrate_guard_page() {
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    
    size_t guard_size;
    pthread_attr_getguardsize(&attr, &guard_size);
    printf("Guard page size: %zu bytes\n", guard_size);  // 보통 4096
    
    // Guard page 비활성화 (위험!)
    pthread_attr_setguardsize(&attr, 0);
}

// Guard Page 동작:
┌──────────────┐
│ Thread 1 Stack│
│      8MB      │
│       ↓       │
├──────────────┤
│  Guard Page   │ ← PROT_NONE (접근 시 SIGSEGV)
├──────────────┤
│ Thread 2 Stack│
│      8MB      │
└──────────────┘

// 스택 오버플로우 시:
// Thread 1이 guard page 접근 → Segmentation Fault
// Thread 2는 보호됨!
```

## 메모리 최적화 전략

### 1. 적절한 스택 크기 설정

```c
// 작업별 스택 크기 가이드
pthread_attr_t attr;
pthread_attr_init(&attr);

// I/O 바운드 작업: 256KB
pthread_attr_setstacksize(&attr, 256 * 1024);

// 일반 작업: 1MB
pthread_attr_setstacksize(&attr, 1024 * 1024);

// 깊은 재귀: 4MB
pthread_attr_setstacksize(&attr, 4 * 1024 * 1024);

// 생성
pthread_create(&thread, &attr, worker, NULL);
```

### 2. 스택 사용량 모니터링

```c
void* monitored_thread(void* arg) {
    // 스택 시작 주소 저장
    char stack_top;
    *(char**)arg = &stack_top;
    
    // 실제 작업
    do_work();
    
    // 스택 끝 확인
    char stack_bottom;
    size_t stack_used = &stack_top - &stack_bottom;
    printf("Stack used: %zu bytes\n", stack_used);
    
    return NULL;
}
```

### 3. 동적 스택 크기 조정

```python
# Python 예제
import threading
import resource

def calculate_stack_size(task_type):
    """작업 유형에 따른 스택 크기 계산"""
    sizes = {
        'io_bound': 256 * 1024,      # 256KB
        'cpu_bound': 512 * 1024,     # 512KB  
        'recursive': 2 * 1024 * 1024, # 2MB
        'default': 1024 * 1024        # 1MB
    }
    return sizes.get(task_type, sizes['default'])

# 스택 크기 설정
threading.stack_size(calculate_stack_size('io_bound'))

# 많은 스레드 생성 가능
threads = []
for I in range(1000):  # 1000 * 256KB = 256MB (가상)
    t = threading.Thread(target=io_worker)
    t.start()
    threads.append(t)
```

## Kubernetes 환경에서의 고려사항

```yaml
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: multi-threaded-app
    resources:
      limits:
        memory: "1Gi"
    env:
    - name: PTHREAD_STACK_SIZE
      value: "262144"  # 256KB
    - name: MAX_THREADS
      value: "100"
```

```c
// 컨테이너에서 스레드 관리
void setup_thread_pool() {
    // cgroup 메모리 제한 확인
    long memory_limit = get_cgroup_memory_limit();
    
    // 안전한 스레드 수 계산
    size_t stack_size = 256 * 1024;  // 256KB
    size_t overhead = 100 * 1024 * 1024;  // 100MB for heap/etc
    
    int max_threads = (memory_limit - overhead) / stack_size;
    max_threads = min(max_threads, 500);  // 상한선
    
    printf("Creating thread pool with %d threads\n", max_threads);
}
```

## 실전 트러블슈팅

### 문제: "pthread_create failed: Resource temporarily unavailable"

```bash
# 진단
$ cat /proc/&lt;pid&gt;/status | grep Threads
Threads: 32768  # 너무 많은 스레드!

# 원인 확인
$ ulimit -u
32768  # 사용자 제한 도달

# 해결
$ ulimit -u 65536  # 제한 증가
```

### 문제: 예상보다 많은 메모리 사용

```bash
# 스택 실제 사용량 확인
$ pmap -x &lt;pid&gt; | grep stack
7f8a2c000000   8192K rw---  [stack:12345]
# RSS 컬럼 확인 → 실제 물리 메모리

# 스레드별 스택 사용량 집계
$ cat /proc/&lt;pid&gt;/smaps | grep -A3 stack | grep Rss | \
  awk '{sum+=$2} END {print sum/1024 " MB"}'
```

## 정리

멀티스레드 스택 메모리의 핵심:

1. **메인 스레드는 특별하다**: 프로세스와 생명주기 공유, 특별한 위치와 데이터
2. **가상 ≠ 물리**: 100스레드 = 가상 800MB, 실제 ~10MB
3. **Demand Paging**: 사용할 때만 물리 메모리 할당
4. **Guard Page**: 스택 간 보호, 오버플로우 방지
5. **최적화 중요**: 작업별 적절한 스택 크기 설정
6. **모니터링 필수**: 가상/물리 메모리 구분해서 확인

"스레드 100개 = 800MB"는 잘못된 상식입니다. 실제로는 각 스레드가 사용하는 만큼만 물리 메모리를 소비합니다. 하지만 모든 스레드가 스택을 많이 사용한다면? 그때는 진짜 800MB가 필요할 수 있으니, 항상 모니터링하고 최적화해야 합니다!

---

## 관련 문서

- [[process-memory-structure]] - 프로세스 메모리 구조 전체적인 이해
- [[page-cache]] - Page Cache와 메모리 관리
- [[cgroup-container-memory]] - 컨테이너 환경에서의 메모리 격리
- [[oom-killer]] - OOM Killer와 메모리 제한

---

**관련 태그**: `#threading` `#memory-management` `#performance-tuning` `#system-programming`