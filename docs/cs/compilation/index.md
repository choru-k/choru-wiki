---
tags:
  - Compilation
  - Compiler
  - Overview
---

# 컴파일레이션 (Compilation)

소스 코드에서 실행 가능한 바이너리까지의 변환 과정을 다룹니다. 컴파일러 내부 동작, 최적화 기법, 그리고 프로덕션 환경에서의 빌드 전략을 심층적으로 설명합니다.

## 주요 내용

### 기본 개념

- 컴파일레이션 과정의 4단계 (전처리, 컴파일, 어셈블, 링킹)
- 컴파일러 내부 동작 원리 (어휘분석, 구문분석, 의미분석, 최적화)
- 주요 컴파일러별 특징 (GCC, Clang, MSVC)
- 링커의 역할과 심볼 해결 과정

### 실무 적용

- 성능 최적화 플래그 활용법
- 디버깅 빌드와 릴리즈 빌드 차이점
- 프로파일 가이드 최적화 (PGO)와 링크 타임 최적화 (LTO)
- Static vs Dynamic linking 전략
- 현대적 링커 활용 (mold, lld)

### 문제 해결

- 일반적인 컴파일 오류와 해결법
- 링커 오류 진단 및 해결
- 의존성 관리와 라이브러리 링킹
- Symbol visibility와 export control

## 문서 목록

### 컴파일 과정

- [컴파일레이션 완벽 가이드: From Source to Binary](compile.md) - 컴파일 과정 전반에 대한 종합적인 설명
- [Linker 완벽 가이드: Symbol Resolution to Link-Time Optimization](linker.md) - 링커의 동작 원리와 최적화 기법

### 빌드 구성요소

- [헤더 파일과 전처리기](header-files.md) - C/C++ 헤더 파일 시스템과 전처리기 동작
- [심볼 테이블 완벽 이해](symbol-table.md) - 바이너리의 심볼 테이블 구조와 활용

### 라이브러리

- [정적 라이브러리 실무 가이드](static-library.md) - 정적 라이브러리 생성과 링킹
- [동적 라이브러리 마스터하기](dynamic-library.md) - 동적 라이브러리의 동작 원리와 최적화

## DevOps/SRE 관점

컴파일레이션은 단순한 코드 변환이 아닌, 시스템 성능과 안정성에 직결되는 중요한 과정입니다:

-**성능**: 적절한 최적화 플래그로 10배 성능 향상 가능
-**크기**: 컨테이너 이미지 크기 최적화를 위한 바이너리 크기 관리
-**보안**: 컴파일 타임 보안 검사와 런타임 보호 기능 활용
-**디버깅**: 프로덕션 문제 해결을 위한 디버그 정보 관리
-**빌드 시간**: 현대적 링커(mold, lld) 활용으로 CI/CD 파이프라인 가속화

효과적인 빌드 전략은 개발 생산성과 운영 효율성을 동시에 향상시킵니다.
